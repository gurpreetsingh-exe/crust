#ifndef TOKEN_H
#define TOKEN_H

#include <span/span.hh>
#include <span/symbol.hh>

namespace crust {

#define BINARY_OPS()                                                           \
  X(Plus)                                                                      \
  X(Minus)                                                                     \
  X(Star)                                                                      \
  X(Slash)                                                                     \
  X(Percent)                                                                   \
  X(Caret)                                                                     \
  X(And)                                                                       \
  X(Or)                                                                        \
  X(Shl)                                                                       \
  X(Shr)

#define DELIMITERS()                                                           \
  X(Parenthesis)                                                               \
  X(Brace)                                                                     \
  X(Bracket)                                                                   \
  X(Invisible)

#define LITERALS()                                                             \
  X(Bool)                                                                      \
  X(Byte)                                                                      \
  X(Char)                                                                      \
  X(Integer)                                                                   \
  X(Float)                                                                     \
  X(Str)                                                                       \
  X(StrRaw)                                                                    \
  X(ByteStr)                                                                   \
  X(ByteStrRaw)                                                                \
  X(CStr)                                                                      \
  X(CStrRaw)                                                                   \
  X(Err)

enum class TokenKind {
  /// Expression-operator symbols.
  Eq,
  Lt,
  Le,
  EqEq,
  Ne,
  Ge,
  Gt,
  AndAnd,
  OrOr,
  Not,
  Tilde,

#define X(bin_op) bin_op,
  /// Binary operators `+`, `*`
  BINARY_OPS()
#undef X

#define X(bin_op) bin_op##Eq,
  /// Binary eq operators `+=`, `*=`
  BINARY_OPS()
#undef X

  /// Structural symbols
  At,
  Dot,
  DotDot,
  DotDotDot,
  DotDotEq,
  Comma,
  Semi,
  Colon,
  ModSep,
  RArrow,
  LArrow,
  FatArrow,
  Pound,
  Dollar,
  Question,
  /// Used by proc macros for representing lifetimes, not generated by lexer
  /// right now.
  SingleQuote,

#define X(delim) Open##delim,
  /// An opening delimiter (e.g., `{`).
  DELIMITERS()
#undef X

#define X(delim) Close##delim,
  /// A closing delimiter (e.g., `}`).
  DELIMITERS()
#undef X

#define X(lit) Lit##lit,
  /// Literals
  LITERALS()
#undef X

  /// Identifier token.
  Ident,
  /// Lifetime identifier token.
  Lifetime,
  /// A doc comment token `//!`, `/*!`.
  DocCommentInner,
  /// A doc comment token `///`, `/**`.
  DocCommentOuter,
  Eof,
};

/// Base of numeric literal encoding according to its prefix.
enum Base : u32 {
  /// Literal starts with "0b".
  Binary = 2,
  /// Literal starts with "0o".
  Octal = 8,
  /// Literal doesn't contain a prefix.
  Decimal = 10,
  /// Literal starts with "0x".
  Hexadecimal = 16,
};

struct Literal {
  Symbol sym;
  Symbol suffix;
};

using TokenExtra = std::variant<Symbol, // Optional field for `Ident`,
                                        // `Lifetime` and `DocComment`

                                Literal // Optional field for `Lit*`
                                >;

struct Token {
  TokenKind kind;
  Span span;
  TokenExtra extra;

  Token() {}
  Token(TokenKind _kind, Span _span, TokenExtra _extra)
      : kind(_kind), span(_span), extra(_extra) {}

  auto ident() -> Option<std::tuple<Ident, bool>>;

  template <typename Callable>
  auto is_raw_non_ident_where(Callable&& cb) -> bool {
    auto id = ident();
    if (not id.has_value()) {
      return false;
    }
    auto [idnt, _] = id.value();
    return cb(idnt);
  }

  auto is_special_ident() -> bool {
    return is_raw_non_ident_where(
        [](Ident ident) { return ident.is_special(); });
  }

  auto is_used_keyword() -> bool {
    return is_raw_non_ident_where(
        [](Ident ident) { return ident.is_used_keyword(); });
  }

  auto is_unused_keyword() -> bool {
    return is_raw_non_ident_where(
        [](Ident ident) { return ident.is_unused_keyword(); });
  }
};

} // namespace crust

template <>
struct fmt::formatter<crust::TokenKind> {
  constexpr auto parse(format_parse_context& ctx)
      -> format_parse_context::iterator {
    return ctx.begin();
  }

  auto format(crust::TokenKind kind, format_context& ctx)
      -> format_context::iterator {
    auto s = std::string_view("unknwown");
    switch (kind) {
      case crust::TokenKind::Eq:
        s = "=";
        break;
      case crust::TokenKind::Lt:
        s = "<";
        break;
      case crust::TokenKind::Le:
        s = "<=";
        break;
      case crust::TokenKind::EqEq:
        s = "==";
        break;
      case crust::TokenKind::Ne:
        s = "!=";
        break;
      case crust::TokenKind::Ge:
        s = ">=";
        break;
      case crust::TokenKind::Gt:
        s = ">";
        break;
      case crust::TokenKind::AndAnd:
        s = "&&";
        break;
      case crust::TokenKind::OrOr:
        s = "||";
        break;
      case crust::TokenKind::Not:
        s = "!";
        break;
      case crust::TokenKind::Tilde:
        s = "~";
        break;
      case crust::TokenKind::At:
        s = "@";
        break;
      case crust::TokenKind::Dot:
        s = ".";
        break;
      case crust::TokenKind::DotDot:
        s = "..";
        break;
      case crust::TokenKind::DotDotDot:
        s = "...";
        break;
      case crust::TokenKind::DotDotEq:
        s = "..=";
        break;
      case crust::TokenKind::Comma:
        s = ",";
        break;
      case crust::TokenKind::Semi:
        s = ";";
        break;
      case crust::TokenKind::Colon:
        s = ":";
        break;
      case crust::TokenKind::ModSep:
        s = "::";
        break;
      case crust::TokenKind::RArrow:
        s = "->";
        break;
      case crust::TokenKind::LArrow:
        s = "<-";
        break;
      case crust::TokenKind::FatArrow:
        s = "=>";
        break;
      case crust::TokenKind::Pound:
        s = "#";
        break;
      case crust::TokenKind::Dollar:
        s = "$";
        break;
      case crust::TokenKind::Question:
        s = "?";
        break;
      case crust::TokenKind::SingleQuote:
        s = "'";
        break;
      case crust::TokenKind::Ident:
        s = "Ident";
        break;
      case crust::TokenKind::Lifetime:
        s = "'a";
        break;
      case crust::TokenKind::DocCommentInner:
        s = "//!";
        break;
      case crust::TokenKind::DocCommentOuter:
        s = "///";
        break;
      case crust::TokenKind::Eof:
        s = "<eof>";
        break;
#define X(bin_op)                                                              \
  case crust::TokenKind::bin_op:                                               \
    s = #bin_op;                                                               \
    break;
        BINARY_OPS()
#undef X

#define X(bin_op)                                                              \
  case crust::TokenKind::bin_op##Eq:                                           \
    s = CAT(bin_op, Eq);                                                       \
    break;
        BINARY_OPS()
#undef X

#define X(delim)                                                               \
  case crust::TokenKind::Open##delim:                                          \
    s = CAT(Open, delim);                                                      \
    break;
        DELIMITERS()
#undef X

#define X(delim)                                                               \
  case crust::TokenKind::Close##delim:                                         \
    s = CAT(Close, delim);                                                     \
    break;
        DELIMITERS()
#undef X

#define X(lit)                                                                 \
  case crust::TokenKind::Lit##lit:                                             \
    s = #lit;                                                                  \
    break;
        LITERALS()
#undef X
    }

    return fmt::format_to(ctx.out(), "{}", s);
  }
};

template <>
struct fmt::formatter<crust::Token> {
  constexpr auto parse(format_parse_context& ctx)
      -> format_parse_context::iterator {
    return ctx.begin();
  }

  auto format(const crust::Token& t, format_context& ctx)
      -> format_context::iterator {
    std::string s;
    switch (t.kind) {
      default:
        break;
      case crust::TokenKind::Ident:
      case crust::TokenKind::DocCommentOuter:
      case crust::TokenKind::DocCommentInner:
      case crust::TokenKind::Lifetime: {
        auto sym = std::get<crust::Symbol>(t.extra);
        s = fmt::format(", sym: \"{}\"", sym);
      } break;
#define X(lit) case crust::TokenKind::Lit##lit:
        LITERALS()
#undef X
        auto lit = std::get<crust::Literal>(t.extra);
        s = fmt::format(", lit: \"{}\"", lit.sym.get());
        break;
    }

    return fmt::format_to(ctx.out(),
                          "Token {{ kind: {}, span: {{ lo: {}, hi: {} }}{} }}",
                          t.kind, t.span.lo, t.span.hi, s);
  }
};

#endif // !TOKEN_H
